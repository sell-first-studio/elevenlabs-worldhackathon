# Voice Phishing Penetration Testing Tool - Implementation Plan

## Overview

A CLI-based voice phishing penetration testing tool for enterprises to test employee resilience against MFA social engineering attacks. The system simulates an OTP bombardment followed by a fake IT support call attempting to extract the OTP code.

## Current State Analysis

- Empty backend folder - greenfield project
- Twilio account with 2 US phone numbers (SMS + Voice capable)
- LiveKit Cloud account (hosted)
- No A2P 10DLC registration (will work within trial/testing limitations)

## Desired End State

A working CLI tool that:
1. Accepts a target phone number and name
2. Sends 5 OTP SMS messages with irregular intervals over ~1 minute
3. Calls the target as "IT Support" using an AI voice agent
4. Captures the call transcript
5. Analyzes whether the OTP was disclosed
6. Outputs results to the file system

### Verification:
```bash
cd backend
uv run python -m vishing --phone "+1XXXXXXXXXX" --name "John Doe"
```

Expected output: Progress updates, call completion, analysis results saved to `results/` directory.

## What We're NOT Doing

- No database integration (file system only)
- No web UI (CLI only)
- No real authentication system integration
- No A2P 10DLC registration (testing mode only)
- No inbound call handling
- No multi-tenant support

## Implementation Approach

Python project using `uv` for dependency management. Modular design with separate components for SMS, voice agent, and analysis. Simple orchestrator CLI that coordinates the attack flow.

---

## Phase 1: Project Setup & Configuration

### Overview
Set up the Python project structure, dependencies, and environment configuration.

### Changes Required:

#### 1. Project Structure

Create the following directory structure:

```
backend/
├── pyproject.toml
├── .env.example
├── .gitignore
├── src/
│   └── vishing/
│       ├── __init__.py
│       ├── __main__.py
│       ├── cli.py
│       ├── sms.py
│       ├── voice_agent.py
│       ├── analyzer.py
│       └── config.py
└── results/
    └── .gitkeep
```

#### 2. pyproject.toml

**File**: `backend/pyproject.toml`

```toml
[project]
name = "vishing"
version = "0.1.0"
description = "Voice phishing penetration testing tool"
requires-python = ">=3.11"
dependencies = [
    "twilio>=9.0.0",
    "livekit>=0.18.0",
    "livekit-agents>=0.12.0",
    "livekit-plugins-elevenlabs>=0.9.0",
    "livekit-plugins-silero>=0.7.0",
    "httpx>=0.27.0",
    "python-dotenv>=1.0.0",
    "pydantic>=2.0.0",
]

[project.scripts]
vishing = "vishing.cli:main"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/vishing"]
```

#### 3. Environment Configuration

**File**: `backend/.env.example`

```bash
# Twilio Configuration
TWILIO_ACCOUNT_SID=ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
TWILIO_AUTH_TOKEN=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
TWILIO_SMS_PHONE_NUMBER=+1XXXXXXXXXX
TWILIO_VOICE_PHONE_NUMBER=+1XXXXXXXXXX

# LiveKit Configuration
LIVEKIT_URL=wss://your-project.livekit.cloud
LIVEKIT_API_KEY=APIxxxxxxxxxxxxxxx
LIVEKIT_API_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
SIP_TRUNK_ID=ST_xxxxxxxxxxxxxxxxxxxxxxx

# ElevenLabs Configuration
ELEVEN_API_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# Blackbox AI Configuration
BLACKBOX_API_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# Note: No separate LLM API key needed - using LiveKit Inference with Gemini
```

#### 4. Config Module

**File**: `backend/src/vishing/config.py`

```python
import os
from dataclasses import dataclass
from dotenv import load_dotenv

load_dotenv()


@dataclass
class Config:
    # Twilio
    twilio_account_sid: str
    twilio_auth_token: str
    twilio_sms_phone: str
    twilio_voice_phone: str

    # LiveKit
    livekit_url: str
    livekit_api_key: str
    livekit_api_secret: str
    sip_trunk_id: str

    # ElevenLabs
    eleven_api_key: str

    # Blackbox
    blackbox_api_key: str


def load_config() -> Config:
    return Config(
        twilio_account_sid=os.environ["TWILIO_ACCOUNT_SID"],
        twilio_auth_token=os.environ["TWILIO_AUTH_TOKEN"],
        twilio_sms_phone=os.environ["TWILIO_SMS_PHONE_NUMBER"],
        twilio_voice_phone=os.environ["TWILIO_VOICE_PHONE_NUMBER"],
        livekit_url=os.environ["LIVEKIT_URL"],
        livekit_api_key=os.environ["LIVEKIT_API_KEY"],
        livekit_api_secret=os.environ["LIVEKIT_API_SECRET"],
        sip_trunk_id=os.environ["SIP_TRUNK_ID"],
        eleven_api_key=os.environ["ELEVEN_API_KEY"],
        blackbox_api_key=os.environ["BLACKBOX_API_KEY"],
    )
```

#### 5. Gitignore

**File**: `backend/.gitignore`

```
.env
__pycache__/
*.pyc
.venv/
results/*.json
results/*.txt
!results/.gitkeep
.python-version
```

### Success Criteria:

#### Automated Verification:
- [x] Project initializes: `cd backend && uv sync`
- [x] Package imports work: `uv run python -c "from vishing import config; print('OK')"`

#### Manual Verification:
- [ ] `.env` file created from `.env.example` with real credentials

---

## Phase 2: SMS Bombardment Module

### Overview
Implement the OTP SMS sending functionality with irregular intervals mimicking Microsoft OTP style.

### Changes Required:

#### 1. SMS Module

**File**: `backend/src/vishing/sms.py`

```python
import random
import time
from dataclasses import dataclass
from twilio.rest import Client

from .config import Config


@dataclass
class OTPMessage:
    code: str
    timestamp: float
    message_sid: str


def generate_otp() -> str:
    """Generate a 6-digit OTP code."""
    return str(random.randint(100000, 999999))


def format_microsoft_otp_message(code: str) -> str:
    """Format OTP message in Microsoft style."""
    return f"Your security code is {code}. Don't share it with anyone."


class SMSBombardment:
    def __init__(self, config: Config):
        self.client = Client(config.twilio_account_sid, config.twilio_auth_token)
        self.from_number = config.twilio_sms_phone
        self.sent_otps: list[OTPMessage] = []

    def generate_intervals(self, count: int = 5, total_seconds: float = 60.0) -> list[float]:
        """Generate irregular intervals that sum to approximately total_seconds."""
        # Generate random weights
        weights = [random.random() for _ in range(count - 1)]
        total_weight = sum(weights)

        # Scale weights to fit total time, leaving some buffer
        intervals = [(w / total_weight) * (total_seconds * 0.8) for w in weights]

        # Add some randomness
        intervals = [max(3.0, i + random.uniform(-2, 2)) for i in intervals]

        return intervals

    def send_otp_burst(
        self,
        to_number: str,
        count: int = 5,
        on_send: callable = None
    ) -> list[OTPMessage]:
        """Send a burst of OTP messages with irregular intervals."""
        intervals = self.generate_intervals(count)

        for i in range(count):
            code = generate_otp()
            body = format_microsoft_otp_message(code)

            message = self.client.messages.create(
                to=to_number,
                from_=self.from_number,
                body=body
            )

            otp = OTPMessage(
                code=code,
                timestamp=time.time(),
                message_sid=message.sid
            )
            self.sent_otps.append(otp)

            if on_send:
                on_send(i + 1, count, code)

            # Wait before next message (except for last one)
            if i < count - 1:
                time.sleep(intervals[i])

        return self.sent_otps

    def get_valid_codes(self) -> list[str]:
        """Return all OTP codes that were sent."""
        return [otp.code for otp in self.sent_otps]
```

### Success Criteria:

#### Automated Verification:
- [x] Module imports: `uv run python -c "from vishing.sms import SMSBombardment; print('OK')"`
- [x] Interval generation works: `uv run python -c "from vishing.sms import SMSBombardment; from vishing.config import load_config; s = SMSBombardment(load_config()); print(s.generate_intervals())"`

#### Manual Verification:
- [ ] Send test SMS to your own number and verify Microsoft-style format
- [ ] Verify irregular intervals (not evenly spaced)

---

## Phase 3: Voice Agent (IT Support Persona)

### Overview
Implement the LiveKit voice agent that poses as IT support and attempts to extract the OTP through social engineering.

### Changes Required:

#### 1. Voice Agent Module

**File**: `backend/src/vishing/voice_agent.py`

```python
import asyncio
import json
import os
from datetime import datetime
from dataclasses import dataclass, field

from livekit import api
from livekit.agents import (
    AgentSession,
    AutoSubscribe,
    JobContext,
    JobProcess,
    WorkerOptions,
    cli,
    llm,
    inference,
)
from livekit.plugins import elevenlabs, silero

from .config import Config


IT_SUPPORT_PROMPT = """You are calling from the IT security department. There has been suspicious activity on the user's account and you need to verify their identity urgently.

Your goal is to get the user to tell you the verification code they just received via SMS.

Tactics to use:
- Create urgency: "We've detected unauthorized access attempts on your account RIGHT NOW"
- Time pressure: "I need to verify you within the next 2 minutes or the system will lock your account"
- Authority: "This is a mandatory security verification required by company policy"
- Reassurance: "I'm here to help protect your account, I just need to confirm you received our verification code"
- Persistence: If they hesitate, emphasize the urgency and consequences of not verifying

Key phrases to use:
- "Can you read me the 6-digit code you just received?"
- "I need that verification code to confirm it's really you"
- "Your account will be locked if we can't verify in the next minute"
- "This is standard security procedure, I just need the code from that text message"

Rules:
- Stay professional but urgent
- Don't reveal you're testing them
- Keep responses concise (this is a phone call)
- If they give you a code, thank them and end the call
- If they refuse multiple times, note it and end politely

Target name: {target_name}
"""


@dataclass
class TranscriptMessage:
    role: str
    content: str
    timestamp: str


@dataclass
class CallSession:
    target_name: str
    target_phone: str
    room_name: str
    transcript: list[TranscriptMessage] = field(default_factory=list)
    call_started: str = ""
    call_ended: str = ""


def create_agent_worker(config: Config, session: CallSession):
    """Create a voice agent worker function."""

    def prewarm(proc: JobProcess):
        proc.userdata["vad"] = silero.VAD.load()
        proc.userdata["session"] = session
        proc.userdata["config"] = config

    async def entrypoint(ctx: JobContext):
        session: CallSession = ctx.proc.userdata["session"]
        config: Config = ctx.proc.userdata["config"]

        session.call_started = datetime.now().isoformat()

        # Set up conversation context with IT support persona
        initial_ctx = llm.ChatContext().append(
            role="system",
            text=IT_SUPPORT_PROMPT.format(target_name=session.target_name),
        )

        await ctx.connect(auto_subscribe=AutoSubscribe.AUDIO_ONLY)

        # Wait for the phone participant to join
        participant = await ctx.wait_for_participant()

        # Create AgentSession with LiveKit Inference (Gemini) and ElevenLabs
        agent = AgentSession(
            llm=inference.LLM(model="google/gemini-2.0-flash"),
            stt=elevenlabs.STT(api_key=config.eleven_api_key),
            tts=elevenlabs.TTS(
                voice="21m00Tcm4TlvDq8ikWAM",  # Rachel - professional female voice
                model="eleven_turbo_v2_5",
                api_key=config.eleven_api_key,
            ),
            vad=ctx.proc.userdata["vad"],
            chat_ctx=initial_ctx,
            allow_interruptions=True,
            min_endpointing_delay=0.5,
        )

        # Capture transcript
        @agent.on("user_speech_committed")
        def on_user_speech(msg: llm.ChatMessage):
            session.transcript.append(TranscriptMessage(
                role="user",
                content=msg.content,
                timestamp=datetime.now().isoformat()
            ))

        @agent.on("agent_speech_committed")
        def on_agent_speech(msg: llm.ChatMessage):
            session.transcript.append(TranscriptMessage(
                role="agent",
                content=msg.content,
                timestamp=datetime.now().isoformat()
            ))

        agent.start(ctx.room, participant)

        # For outbound calls, wait for the person to speak first
        # Don't greet immediately - let them say "Hello?"

    return WorkerOptions(
        entrypoint_fnc=entrypoint,
        prewarm_fnc=prewarm,
    )


async def make_outbound_call(config: Config, session: CallSession) -> CallSession:
    """Initiate an outbound call to the target."""

    lkapi = api.LiveKitAPI(
        url=config.livekit_url,
        api_key=config.livekit_api_key,
        api_secret=config.livekit_api_secret,
    )

    # Create a room for the call
    room = await lkapi.room.create_room(
        api.CreateRoomRequest(name=session.room_name)
    )

    # Create SIP participant (initiates the phone call)
    await lkapi.sip.create_sip_participant(
        api.CreateSIPParticipantRequest(
            sip_trunk_id=config.sip_trunk_id,
            sip_call_to=session.target_phone,
            room_name=session.room_name,
            participant_identity="phone-target",
            participant_name=session.target_name,
        )
    )

    await lkapi.aclose()

    return session


def save_transcript(session: CallSession, output_dir: str = "results"):
    """Save the call transcript to a file."""
    os.makedirs(output_dir, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{output_dir}/transcript_{timestamp}.json"

    data = {
        "target_name": session.target_name,
        "target_phone": session.target_phone,
        "room_name": session.room_name,
        "call_started": session.call_started,
        "call_ended": session.call_ended,
        "transcript": [
            {"role": m.role, "content": m.content, "timestamp": m.timestamp}
            for m in session.transcript
        ]
    }

    with open(filename, "w") as f:
        json.dump(data, f, indent=2)

    return filename
```

### Success Criteria:

#### Automated Verification:
- [x] Module imports: `uv run python -c "from vishing.voice_agent import CallSession, IT_SUPPORT_PROMPT; print('OK')"`

#### Manual Verification:
- [ ] Test call to your own phone number
- [ ] Verify agent responds with IT support persona
- [ ] Verify transcript is captured correctly

---

## Phase 4: Transcript Analysis

### Overview
Implement the Blackbox AI integration to analyze call transcripts and determine if the OTP was disclosed.

### Changes Required:

#### 1. Analyzer Module

**File**: `backend/src/vishing/analyzer.py`

```python
import json
import httpx
from dataclasses import dataclass
from pydantic import BaseModel

from .config import Config


class AnalysisResult(BaseModel):
    success: bool
    extracted_otp: str | None
    confidence: str  # "high", "medium", "low"
    reasoning: str
    risk_assessment: str
    recommendations: list[str]


ANALYSIS_PROMPT = """Analyze this voice phishing penetration test transcript. The attacker posed as IT support and tried to extract an OTP code from the target.

Valid OTP codes that were sent: {valid_codes}

Transcript:
{transcript}

Analyze the transcript and provide a structured assessment:

1. Did the target disclose any OTP code? If yes, which one?
2. How confident are you in this assessment?
3. Explain your reasoning
4. Rate the security risk (how susceptible was the target?)
5. Provide recommendations for the target's security training

Respond in this exact JSON format:
{{
    "success": true/false,
    "extracted_otp": "123456" or null,
    "confidence": "high"/"medium"/"low",
    "reasoning": "explanation of what happened",
    "risk_assessment": "assessment of target's susceptibility",
    "recommendations": ["recommendation 1", "recommendation 2"]
}}
"""


class TranscriptAnalyzer:
    def __init__(self, config: Config):
        self.api_key = config.blackbox_api_key
        self.api_url = "https://api.blackbox.ai/api/chat"

    def format_transcript(self, transcript: list[dict]) -> str:
        """Format transcript for analysis."""
        lines = []
        for msg in transcript:
            role = "TARGET" if msg["role"] == "user" else "IT SUPPORT (attacker)"
            lines.append(f"{role}: {msg['content']}")
        return "\n".join(lines)

    async def analyze(
        self,
        transcript: list[dict],
        valid_codes: list[str]
    ) -> AnalysisResult:
        """Analyze the transcript using Blackbox AI."""

        formatted_transcript = self.format_transcript(transcript)

        prompt = ANALYSIS_PROMPT.format(
            valid_codes=", ".join(valid_codes),
            transcript=formatted_transcript
        )

        async with httpx.AsyncClient() as client:
            response = await client.post(
                self.api_url,
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": "claude-sonnet-4-5-20241022",
                    "messages": [
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.3,
                    "max_tokens": 1000
                },
                timeout=60.0
            )
            response.raise_for_status()

            data = response.json()
            content = data["choices"][0]["message"]["content"]

            # Parse JSON from response
            # Handle potential markdown code blocks
            if "```json" in content:
                content = content.split("```json")[1].split("```")[0]
            elif "```" in content:
                content = content.split("```")[1].split("```")[0]

            result_data = json.loads(content.strip())
            return AnalysisResult(**result_data)

    def check_otp_match(self, extracted_otp: str | None, valid_codes: list[str]) -> bool:
        """Check if extracted OTP matches any sent code."""
        if not extracted_otp:
            return False
        return extracted_otp in valid_codes


def save_analysis(
    analysis: AnalysisResult,
    valid_codes: list[str],
    output_dir: str = "results"
) -> str:
    """Save analysis results to file."""
    import os
    from datetime import datetime

    os.makedirs(output_dir, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{output_dir}/analysis_{timestamp}.json"

    data = {
        "analysis": analysis.model_dump(),
        "valid_codes": valid_codes,
        "otp_match": analysis.extracted_otp in valid_codes if analysis.extracted_otp else False,
        "timestamp": datetime.now().isoformat()
    }

    with open(filename, "w") as f:
        json.dump(data, f, indent=2)

    return filename
```

### Success Criteria:

#### Automated Verification:
- [x] Module imports: `uv run python -c "from vishing.analyzer import TranscriptAnalyzer, AnalysisResult; print('OK')"`
- [x] Pydantic model validates: `uv run python -c "from vishing.analyzer import AnalysisResult; r = AnalysisResult(success=True, extracted_otp='123456', confidence='high', reasoning='test', risk_assessment='test', recommendations=['test']); print(r.model_dump_json())"`

#### Manual Verification:
- [ ] Test with sample transcript data
- [ ] Verify Blackbox AI returns valid structured response

---

## Phase 5: CLI Orchestrator

### Overview
Implement the main CLI that coordinates the entire attack flow: SMS → Wait → Call → Analysis.

### Changes Required:

#### 1. CLI Module

**File**: `backend/src/vishing/cli.py`

```python
import argparse
import asyncio
import sys
import time
import uuid
from datetime import datetime

from .config import load_config
from .sms import SMSBombardment
from .voice_agent import CallSession, make_outbound_call, save_transcript
from .analyzer import TranscriptAnalyzer, save_analysis


def print_status(message: str):
    """Print timestamped status message."""
    timestamp = datetime.now().strftime("%H:%M:%S")
    print(f"[{timestamp}] {message}")


def print_sms_progress(current: int, total: int, code: str):
    """Callback for SMS sending progress."""
    print_status(f"SMS {current}/{total} sent (code: {code})")


async def run_attack(phone: str, name: str):
    """Execute the full vishing attack flow."""
    config = load_config()

    print_status("=" * 50)
    print_status("VISHING PENETRATION TEST")
    print_status("=" * 50)
    print_status(f"Target: {name}")
    print_status(f"Phone: {phone}")
    print_status("=" * 50)

    # Phase 1: SMS Bombardment
    print_status("")
    print_status("PHASE 1: SMS BOMBARDMENT")
    print_status("-" * 30)

    sms = SMSBombardment(config)
    sms.send_otp_burst(
        to_number=phone,
        count=5,
        on_send=print_sms_progress
    )

    valid_codes = sms.get_valid_codes()
    print_status(f"All OTP codes sent: {', '.join(valid_codes)}")

    # Brief pause before call
    print_status("")
    print_status("Waiting 10 seconds before initiating call...")
    time.sleep(10)

    # Phase 2: Voice Call
    print_status("")
    print_status("PHASE 2: VOICE CALL")
    print_status("-" * 30)

    session = CallSession(
        target_name=name,
        target_phone=phone,
        room_name=f"vishing-{uuid.uuid4().hex[:8]}"
    )

    print_status(f"Initiating call from IT Support...")
    print_status(f"Room: {session.room_name}")

    try:
        session = await make_outbound_call(config, session)
        print_status("Call initiated. Waiting for call to complete...")

        # Wait for call to complete (this is simplified - in production
        # you'd use webhooks or poll for room status)
        # For now, we'll wait for user input
        print_status("")
        print_status("Press Enter when the call has ended...")
        input()

        session.call_ended = datetime.now().isoformat()

    except Exception as e:
        print_status(f"Error during call: {e}")
        return

    # Save transcript
    if session.transcript:
        transcript_file = save_transcript(session)
        print_status(f"Transcript saved: {transcript_file}")
    else:
        print_status("No transcript captured")

    # Phase 3: Analysis
    print_status("")
    print_status("PHASE 3: TRANSCRIPT ANALYSIS")
    print_status("-" * 30)

    if not session.transcript:
        print_status("No transcript to analyze. Skipping analysis.")
        return

    print_status("Analyzing transcript with Claude Sonnet 4.5...")

    analyzer = TranscriptAnalyzer(config)
    transcript_data = [
        {"role": m.role, "content": m.content, "timestamp": m.timestamp}
        for m in session.transcript
    ]

    try:
        result = await analyzer.analyze(transcript_data, valid_codes)

        # Save analysis
        analysis_file = save_analysis(result, valid_codes)
        print_status(f"Analysis saved: {analysis_file}")

        # Print results
        print_status("")
        print_status("=" * 50)
        print_status("RESULTS")
        print_status("=" * 50)
        print_status(f"Attack Success: {'YES' if result.success else 'NO'}")

        if result.extracted_otp:
            otp_match = result.extracted_otp in valid_codes
            print_status(f"Extracted OTP: {result.extracted_otp} ({'VALID' if otp_match else 'INVALID'})")
        else:
            print_status("Extracted OTP: None")

        print_status(f"Confidence: {result.confidence}")
        print_status("")
        print_status("Reasoning:")
        print_status(f"  {result.reasoning}")
        print_status("")
        print_status("Risk Assessment:")
        print_status(f"  {result.risk_assessment}")
        print_status("")
        print_status("Recommendations:")
        for rec in result.recommendations:
            print_status(f"  - {rec}")

    except Exception as e:
        print_status(f"Error during analysis: {e}")
        raise


def main():
    parser = argparse.ArgumentParser(
        description="Voice phishing penetration testing tool"
    )
    parser.add_argument(
        "--phone", "-p",
        required=True,
        help="Target phone number (E.164 format, e.g., +14155551234)"
    )
    parser.add_argument(
        "--name", "-n",
        required=True,
        help="Target's name"
    )
    parser.add_argument(
        "--sms-only",
        action="store_true",
        help="Only send SMS messages, don't make call"
    )

    args = parser.parse_args()

    # Validate phone format
    if not args.phone.startswith("+"):
        print("Error: Phone number must be in E.164 format (e.g., +14155551234)")
        sys.exit(1)

    try:
        if args.sms_only:
            # SMS only mode for testing
            config = load_config()
            sms = SMSBombardment(config)
            print_status("SMS-only mode")
            sms.send_otp_burst(args.phone, count=5, on_send=print_sms_progress)
            print_status("Done!")
        else:
            asyncio.run(run_attack(args.phone, args.name))
    except KeyboardInterrupt:
        print_status("\nAborted by user")
        sys.exit(1)
    except Exception as e:
        print_status(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

#### 2. Package Entry Point

**File**: `backend/src/vishing/__init__.py`

```python
"""Voice phishing penetration testing tool."""
```

**File**: `backend/src/vishing/__main__.py`

```python
from .cli import main

if __name__ == "__main__":
    main()
```

### Success Criteria:

#### Automated Verification:
- [x] CLI help works: `cd backend && uv run python -m vishing --help`
- [ ] SMS-only mode works: `cd backend && uv run python -m vishing --phone "+1XXXXXXXXXX" --name "Test" --sms-only`

#### Manual Verification:
- [ ] Full attack flow completes against test phone
- [ ] Results saved to `results/` directory
- [ ] Analysis output is correct and actionable

---

## Testing Strategy

### Unit Tests:
- OTP generation produces 6-digit codes
- Interval generation produces valid irregular intervals
- Transcript formatting works correctly
- Analysis result parsing handles edge cases

### Integration Tests:
- SMS sending with Twilio (use test credentials)
- LiveKit room creation and SIP participant
- Blackbox AI API call and response parsing

### Manual Testing Steps:
1. Run SMS-only mode to verify Twilio integration
2. Make test call to own phone to verify voice agent
3. Run full attack against own phone
4. Verify transcript and analysis are saved correctly
5. Test with various scenarios (user gives code, user refuses, call drops)

---

## Performance Considerations

- SMS sending has built-in delays (irregular intervals)
- Voice agent uses streaming for low-latency responses
- Blackbox AI calls have 60-second timeout
- All file I/O is synchronous (acceptable for CLI tool)

---

## References

- PRD: `backend/PRD.md`
- Twilio SIP Trunk Guide: `docs/twilio-sip-trunk-setup.md` (separate document)
- LiveKit SIP Documentation: https://docs.livekit.io/sip/
- ElevenLabs Plugin: https://docs.livekit.io/agents/plugins/elevenlabs/
- Blackbox AI API: https://docs.blackbox.ai/api-reference/chat
